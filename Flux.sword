
compilation_unit ->
	  definition*

definition ->
	  attributes?
	  modifier* definition_keyword identifier type_parameters? value_parameters? ( ":" type? )?
	  clause*
	  definition_body

definition_keyword ->
	  "type"
    | "function"
    | "object"
    | "method"
    | "field"
    | "module"
    | "features"
    | "namespace"
    | "local"

definition_body ->
	  ";"
	| "=" expression ";"
	| "{" statement* "}"

statement ->
	  ";"
	| "{" statement* "}"
	| "loop" ( "(" ... ")" )? statement
	| "continue" ";"
	| "break" ";"
	| "throw" expression ";"
	| "return" expression ";"
	| "yield" expression ";"
	| "if" "(" expression ")" statement ( "else" statement )?
	| "switch" "(" expression ")" "{" ( "case" expression,"," ":" statement )* "}"
	| "try" ( "(" expression ")" )? statement ( "finally" statement )?
	| definition
	| expression ";"

////REVIEW: don't try to solve operator precedence at the syntactic level; this is semantics

expression ->
	  "(" expression ")"
	| ( identifier | "resend" ) type_arguments? value_arguments?
	| expression "." identifier
	| expression binary_operator expression
	| unary_prefix_operator expression
	| expression unary_postfix_operator
	| "object" ":" type ( "{" ... "}" )?
	| literal

literal ->
	  integer_literal

integer_literal ->
	  '[0-9]+(b|B|l|L)'
	| '0x[0-9A-Fa-f]+(b|B|l|L)'

binary_operator ->
	  "&&"
	| "||"
	| "+"
	| "-"
	| "/"
	| "*"
	| "%"

unary_prefix_operator ->
	  "++"
    | "--"
    | "!"
    | "-"

unary_postfix_operator ->
	  "++"
    | "--"

type_parameters ->
	  "<" {type_parameter:::","} ">"

type_parameter ->
	  ( modifier* identifier ":" )? type ( "=" type )?

value_parameters ->
	  "(" {value_parameter:::","} ")"

value_parameter ->
	  ( modifier* identifier ":" )? type ( "=" expression )?

type_arguments ->
	  "<" {type:::","} ">"

value_arguments ->
	  "(" {expression:::","} ")"

type ->
	  modifier* identifier type_arguments?
	| "(" {type_parameter:::","} ")" // May be a tuple type or just a parenthesized type expression.
    | type "->" type
    | type "&" type
    | type "|" type

identifier ->
	  ( "::" )? {name:::"::"}

name ->
	  '[[:APHABETIC]_][[:APHANUMERIC:]_]*(!)?'

modifier ->
	  "abstract"
	| "immutable"
	| "mutable"
	| "extend"
	| "instantiable"
	| "import"
	| "include"
	| "final"
	| "sealed"
	| "iterator"
	| "before"
	| "after"
	| "around"
	| "default"
	| "read"
	| "write"
	| "private"
	| "protected"
	| "using"
	| "external"

clause ->
	  "when" expression
    | "requires" expression
	| "ensures" expression
	| "invariant" expression
	| "import" identifier ( "as" identifier )?
	| "undefine" identifier

attributes ->
	  ( "[" attribute* "]" )*

attribute ->
	  identifier ( "(" value_arguments ")" )?
